<tool id="scp_full_workflow" name="scp: Single Cell Proteomics data analysis" version="@TOOL_VERSION@+galaxy0" profile="23.0">
    <description>Single Cell Proteomics workflow</description>
    <macros>
        <import>macros.xml</import>
        <import>help.xml</import>
    </macros>
    <edam_topics>  
    </edam_topics>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">bioconductor-scp</requirement>
        <requirement type="package" version="3.54.0">bioconductor-sva</requirement>
        <requirement type="package" version="1.80.0">bioconductor-impute</requirement>
        <requirement type="package" version="1.34.0">bioconductor-scater</requirement>
    </requirements>
    <expand macro="creator" />
    <command detect_errors="aggressive"><![CDATA[
    Rscript  -e 'source("${__tool_directory__}/utils.R")' -e 'source("${run_script}")'
    ]]></command>
    <configfiles>
        <configfile name="run_script"><![CDATA[
        library("scp")
        library("ggplot2")
        library("dplyr")
        library("sva")  
        library("impute")

        data_input <- read.delim("$input_data", sep="\t")

        metadata <- read.delim("$input_annotations", sep="\t")

        runCol <- colnames(data_input)[$runcol]
        scp <- scp::readSCP(assayData = data_input,
                       colData = metadata,
                       runCol = runCol,
                       removeEmptyCols = $remove_empty_columns)
        
        dir.create("plots")

        number_of_assays <- length(scp)

        scp <- zeroIsNA(scp, i = 1:number_of_assays)

        #if $filtering_data.filter_reverse
        scp <- filterFeatures(scp,
                        ~ Reverse != "+")
        #end if

        #if $filtering_data.filter_contaminants
        scp <- filterFeatures(scp,
                        ~ Potential.contaminant != "+")
        #end if

 
        scp <- filterFeatures(scp,
                      ~ !is.na(PIF) & PIF > ${filtering_data.PIF_threshold})

        keepAssay <- dims(scp)[1, ] > ${filtering_data.minimum_features}
        scp <- scp[, , keepAssay]
        
        number_of_assays <- length(scp)

        single_cell_channels <- gsub(",", "|", "${filtering_data.single_cells}")
        scp <- computeSCR(scp,
                  i = 1:number_of_assays,
                  colvar = "SampleType",
                  carrierPattern = "Carrier",
                  samplePattern = single_cell_channels,
                  sampleFUN = "mean",
                  rowDataName = "MeanSCR")
        
        #if $generate_QC_plots
        QC_plot_SCR <- rbindRowData(scp, i = 1:number_of_assays) |>
                        data.frame() |>
                        ggplot(aes(x = MeanSCR)) +
                        geom_histogram() +
                        geom_vline(xintercept = c(1/$count_cell_carrier, 0.1),
                                                lty = c(2, 1)) +
                        scale_x_log10()
        ggplot2::ggsave(filename = file.path("plots", "QC_plot_SCR.png"), QC_plot_SCR)
        
        QC_plot_SCR_col <- rbindRowData(scp, i = 1:number_of_assays) |>
                            data.frame() |>
                            ggplot(aes(x = MeanSCR, color = runCol)) +
                            geom_density() +
                            geom_vline(xintercept = 0.02, lty = 2) +
                            geom_vline(xintercept = 1, lty = 1)+
                            scale_x_log10()        
        ggplot2::ggsave(filename = file.path("plots", "QC_plot_SCR_col.png"), QC_plot_SCR_col)

        #end if

        scp <- filterFeatures(scp,
                      ~ !is.na(MeanSCR) &
                        MeanSCR < ${filtering_data.SCR_threshold})    

        #if $filtering_data.qvalue_level == "PSM"
        scp <- pep2qvalue(scp,
                    i = 1:number_of_assays,
                    PEP = "dart_PEP",
                    rowDataName = "qvalue")
  
        scp <- filterFeatures(scp,
                        ~ qvalue < ${filtering_data.qvalue_threshold})
        #else
        scp <- pep2qvalue(scp,
                    i = 1:number_of_assays,
                    PEP = "dart_PEP",
                    groupBy = "$filtering_data.qvalue_level",
                    rowDataName = "qvalue")
 
        scp <- filterFeatures(scp,
                        ~ qvalue < ${filtering_data.qvalue_threshold})
        #end if

        #if $filtering_data.divide_reference
        scp <- divideByReference(scp,
                           i = 1:number_of_assays,
                           colvar = "SampleType",
                           samplePattern = ".",
                           refPattern = "Reference")
        #end if

        ## aggregation_fun <- match.fun("${peptide_aggregation.aggregation_peptides}")
        scp <- aggregateFeaturesOverAssays(scp,
                                   i = 1:number_of_assays,
                                   fcol = "${peptide_aggregation.column_aggregation_peptides}",
                                   name = paste0("peptide_", names(scp)),
                                   fun = ${peptide_aggregation.aggregation_peptides}, na.rm = TRUE)

        scp <- joinAssays(scp,
                  i = grep("peptide", names(scp)),
                  name = "peptides")
   
        keep_samples <- unlist(strsplit("${peptide_filtering.samples_to_keep}", split=","))
        scp <- scp[,colData(scp)[["SampleType"]] %in% keep_samples, ]

        #if $peptide_filtering.filter_median_intensity.cut_median_intensity == "yes"
            medians <- colMedians(assay(scp[["peptides"]]), na.rm = TRUE)
            colData(scp)[["MedianRI"]] <- medians

            #if $generate_QC_plots
            QC_medianRI <- colData(scp) |>
                            data.frame() |>
                            ggplot() +
                            aes(x = MedianRI,
                                y = SampleType,
                                fill = SampleType) +
                            geom_boxplot() +
                            scale_x_log10()
            ggplot2::ggsave(filename = file.path("plots", "QC_medianRI.png"), QC_medianRI)
            #end if

            scp <- scp[, !is.na(colData(scp)[["MedianRI"]]) & colData(scp)[["MedianRI"]] < ${peptide_filtering.filter_median_intensity.median_intensity_threshold}, ]
        #end if

        #if $peptide_filtering.filter_median_CV.cut_median_CV == "yes"
        number_of_observations <- ${peptide_filtering.filter_median_CV.minimum_peptides_CV}
        CV_threshold <- ${peptide_filtering.filter_median_CV.median_CV_threshold}
        scp <- medianCVperCell(scp,
                         i = 1:number_of_assays,
                         groupBy = "Leading.razor.protein",
                         nobs = number_of_observations,
                         norm = "div.median",
                         na.rm = TRUE,
                         colDataName = "MedianCV")

            #if $generate_QC_plots
            QC_medianCV <- getWithColData(scp, "peptides") |>
                            colData() |>
                            data.frame() |>
                            ggplot(aes(x = MedianCV,
                                       fill = SampleType)) +
                            geom_boxplot() +
                            geom_vline(xintercept = CV_threshold)
            ggplot2::ggsave(filename = file.path("plots", "QC_medianCV.png"), QC_medianCV)
            #end if

        scp <- scp[, !is.na(colData(scp)[["MedianCV"]]) & colData(scp)[["MedianCV"]] < CV_threshold, ]
        #end if
        
        #if $peptide_filtering.remove_blank
        scp <- scp[, colData(scp)[["SampleType"]] != "Blank", ]
        #end if

        #if $peptide_processing.normalization_method.choose_normalization == "simple"
        scp <- QFeatures::normalize(scp,
              i = "peptides",
              name = "peptides_norm",
              method = "${peptide_processing.normalization_method.normalize_simple_method}")

        #else
        norm_function_col <- match.fun("$peptide_processing.normalization_method.normalize_columns")
        scp <- sweep(scp,
                 i = "peptides", 
                 MARGIN = 2,
                 FUN = "/",
                 STATS = norm_function_col(assay(scp[["peptides"]]), na.rm = TRUE),
                 name = "peptides_norm_col")

        norm_function_row <- match.fun("$peptide_processing.normalization_method.normalize_rows")
        scp <- sweep(scp,
                 i = "peptides_norm_col",
                 MARGIN = 1,
                 FUN = "/",
                 STATS = norm_function_row(assay(scp[["peptides_norm_col"]]),  na.rm = TRUE),
                 name =  "peptides_norm") 
        #end if

        scp <- logTransform(scp,
                    base = ${peptide_processing.base},
                    i = "peptides_norm",
                    name = "peptides_log")

        #if $generate_QC_plots
        QC_boxplot_peptide <- create_boxplots(scp, "peptides", FALSE, "Peptides not normalized")
        QC_boxplot_peptide_norm <- create_boxplots(scp, "peptides_log", TRUE, "Peptides normalized")

        ggplot2::ggsave(filename = file.path("plots", "QC_boxplot_peptide.png"), QC_boxplot_peptide)
        ggplot2::ggsave(filename = file.path("plots", "QC_boxplot_peptide_norm.png"), QC_boxplot_peptide_norm)
        #end if

        #if $peptide_processing.remove_missing_peptides.remove_peptides == "yes"
        pNA <-  ${peptide_processing.remove_missing_peptides.pNA_peptides} / 100
        scp <- filterNA(scp,
                  i = "peptides_log",
                  pNA = pNA)
        #end if

        ## aggregation_fun_prot <- match.fun("${protein_aggregation.aggregation_proteins}")
        scp <- aggregateFeatures(scp,
                         i = "peptides_log",
                         name = "proteins",
                         fcol = "${protein_aggregation.column_aggregation_proteins}",
                         fun = ${protein_aggregation.aggregation_proteins}, na.rm = TRUE)

        #if $protein_processing.normalization_method_protein.choose_normalization_protein == "simple_prot"
       scp <- QFeatures::normalize(scp,
              i = "proteins",
              name = "proteins_norm",
              method = "${protein_processing.normalization_method_protein.normalize_simple_method_prot}")
        #else
        norm_function_col <- match.fun("${protein_processing.normalization_method_protein.normalize_columns_prot}")
        scp <- sweep(scp,
                 i = "proteins", 
                 MARGIN = 2,
                 FUN = "/",
                 STATS = norm_function_col(assay(scp[["proteins"]]), na.rm = TRUE),
                 name = "proteins_norm_col")

        norm_function_row <- match.fun("${protein_processing.normalization_method_protein.normalize_rows_prot}")
        scp <- sweep(scp,
                 i = "proteins_norm_col",
                 MARGIN = 1,
                 FUN = "/",
                 STATS = norm_function_row(assay(scp[["proteins_norm_col"]]),  na.rm = TRUE),
                 name =  "proteins_norm") 
        #end if

        #if $generate_QC_plots
        QC_boxplot_protein <- create_boxplots(scp, "proteins", TRUE, "Proteins not normalized")
        QC_boxplot_protein_norm <- create_boxplots(scp, "proteins_norm", TRUE, "Proteins normalized")
        
        ggplot2::ggsave(filename = file.path("plots", "QC_boxplot_protein.png"), QC_boxplot_protein)
        ggplot2::ggsave(filename = file.path("plots", "QC_boxplot_protein_norm.png"), QC_boxplot_protein_norm)
        
        png(
            filename = file.path("plots", "QC_heatmap_proteins.png"), 
            width = 4, 
            height = 4,
            units = "in",
            res = 1200
        )
        QC_heatmap <- plot_heatmap(scp, "proteins_norm")
        dev.off()
        ##ggplot2::ggsave(filename = file.path("plots", "QC_heatmap_proteins.png"), QC_heatmap)
        #end if

        scp <- impute(scp,
              i = "proteins_norm",
              name = "proteins_imptd",
              method = "knn",
              k = ${protein_processing.impute_k}, rowmax = 1, colmax= 1,
              maxp = Inf, rng.seed = 1234)

        #if $batch_correction.select_batch_correction.batch_correction_method == "combat"
        sce <- getWithColData(scp, "proteins_imptd")
        batch_colname <- colnames(metadata)[${batch_correction.select_batch_correction.batch_col}]
        batch <- colData(scp)[[batch_colname]]
        model <- model.matrix(~ SampleType, data = colData(sce))
  
        assay(sce) <- ComBat(dat = assay(sce),
                       batch = batch,
                       mod = model)

        scp <- addAssay(scp,
                        y = sce,
                        name = "proteins_batchC")

        scp <- addAssayLinkOneToOne(scp,
                              from = "proteins_imptd",
                              to = "proteins_batchC")

        #else
        sce <- getWithColData(scp, "proteins_imptd")
        batch_colname <- colnames(metadata)[${batch_correction.select_batch_correction.batch_col}]
        preserve_colname <- colnames(metadata)[${batch_correction.select_batch_correction.preserve_col}]

        assay(sce) <- limma::removeBatchEffect(
            assay(sce),
            group = sce[[preserve_colname]],
            batch = sce[[batch_colname]]
        )
        scp <- addAssay(scp,
                  y = sce,
                  name = "proteins_batchC")
        scp <- addAssayLinkOneToOne(scp,
                              from = "proteins_imptd",
                              to = "proteins_batchC")
        #end if 

        #if $dimensionality_reduction.PCA_computation.run_PCA == "yes"
        scp[["proteins_batchC"]] <- scater::runPCA(scp[["proteins_batchC"]],
                                     ncomponents = ${dimensionality_reduction.PCA_computation.ncomponents_PCA},
                                     ntop = Inf,
                                     scale = TRUE,
                                     exprs_values = 1,
                                     name = "PCA")
  
        pca <- scater::plotReducedDim(scp[["proteins_batchC"]],
                 dimred = "PCA",
                 colour_by = "SampleType",
                 point_alpha = 1)

            ggplot2::ggsave(filename = file.path("plots", "PCA.png"), pca)

        #if $dimensionality_reduction.PCA_computation.UMAP_computation.run_UMAP == "yes"
        scp[["proteins_batchC"]] <- scater::runUMAP(scp[["proteins_batchC"]],
                                      ncomponents = ${dimensionality_reduction.PCA_computation.UMAP_computation.ncomponents_UMAP},
                                      ntop = Inf,
                                      scale = TRUE,
                                      exprs_values = 1,
                                      n_neighbors = 3,
                                      dimred = "PCA",
                                      name = "UMAP")
  
        umap <- scater::plotReducedDim(scp[["proteins_batchC"]],
                 dimred = "UMAP",
                 colour_by = "SampleType",
                 point_alpha = 1)
        ggplot2::ggsave(filename = file.path("plots", "UMAP.png"), umap)
        #end if

        #end if

        assay_df <- as.data.frame(assay(scp, "proteins_batchC"))
        row_metadata <- as.data.frame(rowData(scp[["proteins_batchC"]]))

        export_data <- cbind(row_metadata, as.data.frame(assay_df))
        write.table(export_data, file = '$Processed_data', sep = "\t", quote=F)
        #if $data_export.export_tables
        export_all_assays(scp)
        #end if

        
        ]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="scp_param"/>
    </inputs>
    <outputs>
        <data name="Processed_data" format="tabular" label="Batch-corrected protein levels"/>
        <collection name="intermediate_outputs" type="list" label="Intermediate outputs">
            <discover_datasets pattern="__name_and_ext__" directory="outputs" />
            <filter>data_export['export_tables']</filter>
        </collection>
        <collection name="plots" type="list" label="Plots">
            <discover_datasets pattern="__name_and_ext__" directory="plots" />
                <filter>generate_QC_plots or dimensionality_reduction['PCA_computation']['run_PCA'] == 'yes' or dimensionality_reduction['PCA_computation']['run_PCA'] == 'yes'</filter>
        </collection>
    </outputs>
    <tests>
        <test expect_num_outputs='2'>
            <param name="input_data" value="evidence_subset.txt" />
            <param name="input_annotations" value="sampleAnnotation.txt"/>
            <param name="runcol" value="19"/>
            <param name="single_cells" value="Macrophage,Monocyte"/>
            <param name="samples_to_keep" value="Macrophage,Monocyte,Blank"/>
            <param name="batch_col" value="2"/>
            <output name="Processed_data">
                <assert_contents>
                    <has_n_lines n="90"/>                
                </assert_contents>
            </output>
        </test>
        <test expect_num_outputs='2'>
            <param name="input_data" value="evidence_subset.txt" />
            <param name="input_annotations" value="sampleAnnotation.txt"/>
            <param name="runcol" value="19"/>
            <param name="single_cells" value="Macrophage,Monocyte"/>
            <param name="samples_to_keep" value="Macrophage,Monocyte,Blank"/>
            <param name="batch_col" value="2"/>
            <output_collection name="plots" type="list">
                <element name="PCA" file="PCA.png" ftype="png" compare="sim_size" delta="600">
                    <assert_contents>
                        <has_image_width width="2100"/>
                        <has_image_height height="2100"/>
                    </assert_contents>
                </element>
                <element name="QC_boxplot_peptide" file="QC_boxplot_peptide.png" ftype="png"/>
                <element name="QC_boxplot_peptide_norm" file="QC_boxplot_peptide_norm.png" ftype="png"/>
                <element name="QC_boxplot_protein" file="QC_boxplot.png" ftype="png"/>
                <element name="QC_boxplot_protein_norm" file="QC_boxplot_protein_norm.png" ftype="png"/>
                <element name="QC_heatmap_proteins" file="QC_heatmap_proteins.png" ftype="png"/>
                <element name="QC_medianCV" file="QC_medianCV.png" ftype="png"/>
                <element name="QC_plot_SCR" file="QC_plot_SCR.png" ftype="png"/>
                <element name="QC_plot_SCR_col" file="QC_plot_SCR_col.png" ftype="png"/>
                <element name="UMAP" file="UMAP.png" ftype="png" compare="sim_size" delta="600">
                    <assert_contents>
                        <has_image_width width="2100"/>
                        <has_image_height height="2100"/>
                    </assert_contents>
                </element>
            </output_collection>
            <output name="Processed_data">
                <assert_contents>
                    <has_n_lines n="90"/>                
                </assert_contents>
            </output>
        </test>
        <test expect_num_outputs='3'>
            <param name="input_data" value="evidence_subset.txt" />
            <param name="input_annotations" value="sampleAnnotation.txt"/>
            <param name="runcol" value="19"/>
            <param name="single_cells" value="Macrophage,Monocyte"/>
            <param name="samples_to_keep" value="Macrophage,Monocyte,Blank"/>
            <param name="batch_col" value="2"/>
            <param name="export_tables" value="true"/>
            <output_collection name="intermediate_outputs" type="list" count="6"/>
            <output name="Processed_data">
                <assert_contents>
                    <has_n_lines n="90"/>                
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
        @GENERAL_HELP@
    ]]></help>
    <expand macro="citations" />
</tool>