<tool id="scp_full_workflow" name="scp: Single Cell Proteomics data analysis" version="@TOOL_VERSION@+galaxy0" profile="23.0">
    <description>Single Cell Proteomics workflow</description>
    <macros>
        <import>macros.xml</import>
        <import>help.xml</import>
    </macros>
    <edam_topics>  
    </edam_topics>
    <expand macro="creator" />
    <command detect_errors="exit_code"><![CDATA[
    Rscript  -e 'source("${__tool_directory__}/utils.R")' -e 'source("${run_script}")'
    ]]></command>
    <configfiles>
        <configfile name="run_script"><![CDATA[
        library("scp")
        library("ggplot2")
        library("dplyr")
        library("sva")  
        library("impute")

        data_input <- read.delim("$input_data", sep="\t")

        metadata <- read.delim("$input_annotations", sep="\t")

        runCol <- colnames(data_input)[$runcol]
        scp <- scp::readSCP(assayData = data_input,
                       colData = metadata,
                       runCol = runCol,
                       removeEmptyCols = $remove_empty_columns)
        
        number_of_assays <- length(scp)

        scp <- zeroIsNA(scp, i = 1:number_of_assays)

        #if $filtering_data.filter_reverse
        scp <- filterFeatures(scp,
                        ~ Reverse != "+")
        #end if

        #if $filtering_data.filter_contaminants
        scp <- filterFeatures(scp,
                        ~ Potential.contaminant != "+")
        #end if

 
        scp <- filterFeatures(scp,
                      ~ !is.na(PIF) & PIF > ${filtering_data.PIF_threshold})

        keepAssay <- dims(scp)[1, ] > ${filtering_data.minimum_features}
        scp <- scp[, , keepAssay]
        
        number_of_assays <- length(scp)

        single_cell_channels <- gsub(",", "|", "${filtering_data.single_cells}")
        scp <- computeSCR(scp,
                  i = 1:number_of_assays,
                  colvar = "SampleType",
                  carrierPattern = "Carrier",
                  samplePattern = single_cell_channels,
                  sampleFUN = "mean",
                  rowDataName = "MeanSCR")
        
        scp <- filterFeatures(scp,
                      ~ !is.na(MeanSCR) &
                        MeanSCR < ${filtering_data.SCR_threshold})    

        #if $filtering_data.qvalue_level == "PSM"
        scp <- pep2qvalue(scp,
                    i = 1:number_of_assays,
                    PEP = "dart_PEP",
                    rowDataName = "qvalue")
  
        scp <- filterFeatures(scp,
                        ~ qvalue < ${filtering_data.qvalue_threshold})
        #else
        scp <- pep2qvalue(scp,
                    i = 1:number_of_assays,
                    PEP = "dart_PEP",
                    groupBy = "$filtering_data.qvalue_level",
                    rowDataName = "qvalue")
 
        scp <- filterFeatures(scp,
                        ~ qvalue < ${filtering_data.qvalue_threshold})
        #end if

        #if $filtering_data.divide_reference
        scp <- divideByReference(scp,
                           i = 1:number_of_assays,
                           colvar = "SampleType",
                           samplePattern = ".",
                           refPattern = "Reference")
        #end if

        aggregation_fun <- match.fun("${peptide_aggregation.aggregation_peptides}")
        scp <- aggregateFeaturesOverAssays(scp,
                                   i = 1:number_of_assays,
                                   fcol = "${peptide_aggregation.column_aggregation_peptides}",
                                   name = paste0("peptide_", names(scp)),
                                   fun = aggregation_fun, na.rm = TRUE)

        scp <- joinAssays(scp,
                  i = grep("peptide", names(scp)),
                  name = "peptides")
   
        keep_samples <- unlist(strsplit("${peptide_filtering.samples_to_keep}", split=","))
        scp <- scp[,colData(scp)[["SampleType"]] %in% keep_samples, ]
 
        #if $peptide_filtering.filter_median_intensity.cut_median_intensity == "yes"
            medians <- colMedians(assay(scp[["peptides"]]), na.rm = TRUE)
            colData(scp)[["MedianRI"]] <- medians
            scp <- scp[, !is.na(colData(scp)[["MedianRI"]]) & colData(scp)[["MedianRI"]] < ${peptide_filtering.filter_median_intensity.median_intensity_threshold}, ]
        #end if
       
        #if $peptide_filtering.filter_median_CV.cut_median_CV == "yes"
        number_of_observations <- ${peptide_filtering.filter_median_CV.minimum_peptides_CV}
        CV_threshold <- ${peptide_filtering.filter_median_CV.median_CV_threshold}
        scp <- medianCVperCell(scp,
                         i = 1:number_of_assays,
                         groupBy = "Leading.razor.protein",
                         nobs = number_of_observations,
                         norm = "div.median",
                         na.rm = TRUE,
                         colDataName = "MedianCV")

        scp <- scp[, !is.na(colData(scp)[["MedianCV"]]) & colData(scp)[["MedianCV"]] < CV_threshold, ]
        #end if
        
        #if $peptide_filtering.remove_blank
        scp <- scp[, colData(scp)[["SampleType"]] != "Blank", ]
        #end if

        #if $peptide_processing.normalization_method.choose_normalization == "simple"
        scp <- QFeatures::normalize(scp,
              i = "peptides",
              name = "peptides_norm",
              method = "${peptide_processing.normalization_method.normalize_simple_method}")

        #else
        norm_function_col <- match.fun("$peptide_processing.normalization_method.normalize_columns")
        scp <- sweep(scp,
                 i = "peptides", 
                 MARGIN = 2,
                 FUN = "/",
                 STATS = norm_function_col(assay(scp[["peptides"]]), na.rm = TRUE),
                 name = "peptides_norm_col")

        norm_function_row <- match.fun("$peptide_processing.normalization_method.normalize_rows")
        scp <- sweep(scp,
                 i = "peptides_norm_col",
                 MARGIN = 1,
                 FUN = "/",
                 STATS = norm_function_row(assay(scp[["peptides_norm_col"]]),  na.rm = TRUE),
                 name =  "peptides_norm") 
        #end if

        scp <- logTransform(scp,
                    base = ${peptide_processing.base},
                    i = "peptides_norm",
                    name = "peptides_log")

        #if $peptide_processing.remove_missing_peptides.remove_peptides == "yes"
        pNA <-  ${peptide_processing.remove_missing_peptides.pNA_peptides} / 100
        scp <- filterNA(scp,
                  i = "peptides_log",
                  pNA = pNA)
        #end if

        aggregation_fun_prot <- match.fun("${protein_aggregation.aggregation_proteins}")
        scp <- aggregateFeatures(scp,
                         i = "peptides_log",
                         name = "proteins",
                         fcol = "${protein_aggregation.column_aggregation_proteins}",
                         fun = aggregation_fun_prot, na.rm = TRUE)

        #if $protein_processing.normalization_method_protein.choose_normalization_protein == "simple_prot"
       scp <- QFeatures::normalize(scp,
              i = "proteins",
              name = "proteins_norm",
              method = "${protein_processing.normalization_method_protein.normalize_simple_method_prot}")
        #else
        norm_function_col <- match.fun("${protein_processing.normalization_method_protein.normalize_columns_prot}")
        scp <- sweep(scp,
                 i = "proteins", 
                 MARGIN = 2,
                 FUN = "/",
                 STATS = norm_function_col(assay(scp[["proteins"]]), na.rm = TRUE),
                 name = "proteins_norm_col")

        norm_function_row <- match.fun("${protein_processing.normalization_method_protein.normalize_rows_prot}")
        scp <- sweep(scp,
                 i = "proteins_norm_col",
                 MARGIN = 1,
                 FUN = "/",
                 STATS = norm_function_row(assay(scp[["proteins_norm_col"]]),  na.rm = TRUE),
                 name =  "proteins_norm") 
        #end if

        scp <- impute(scp,
              i = "proteins_norm",
              name = "proteins_imptd",
              method = "knn",
              k = ${protein_processing.impute_k}, rowmax = 1, colmax= 1,
              maxp = Inf, rng.seed = 1234)

        #if $batch_correction.select_batch_correction.batch_correction_method == "combat"
        sce <- getWithColData(scp, "proteins_imptd")
        batch_colname <- colnames(metadata)[${batch_correction.select_batch_correction.batch_col}]
        batch <- colData(scp)[[batch_colname]]
        model <- model.matrix(~ SampleType, data = colData(sce))
  
        assay(sce) <- ComBat(dat = assay(sce),
                       batch = batch,
                       mod = model)

        scp <- addAssay(scp,
                        y = sce,
                        name = "proteins_batchC")

        scp <- addAssayLinkOneToOne(scp,
                              from = "proteins_imptd",
                              to = "proteins_batchC")

        #else
        sce <- getWithColData(scp, "proteins_imptd")
        batch_colname <- colnames(metadata)[${batch_correction.select_batch_correction.batch_col}]
        preserve_colname <- colnames(metadata)[${batch_correction.select_batch_correction.preserve_col}]

        assay(sce) <- limma::removeBatchEffect(
            assay(sce),
            group = sce[[preserve_colname]],
            batch = sce[[batch_colname]]
        )
        scp <- addAssay(scp,
                  y = sce,
                  name = "proteins_batchC")
        scp <- addAssayLinkOneToOne(scp,
                              from = "proteins_imptd",
                              to = "proteins_batchC")
        #end if 

        #if $dimensionality_reduction.PCA_computation.run_PCA == "yes"
        scp[["proteins_batchC"]] <- scater::runPCA(scp[["proteins_batchC"]],
                                     ncomponents = ${dimensionality_reduction.PCA_computation.ncomponents_PCA},
                                     ntop = Inf,
                                     scale = TRUE,
                                     exprs_values = 1,
                                     name = "PCA")
  
        pca <- scater::plotReducedDim(scp[["proteins_batchC"]],
                 dimred = "PCA",
                 colour_by = "SampleType",
                 point_alpha = 1)

        ggplot2::ggsave(filename = "PCA.png", pca)

        #if $dimensionality_reduction.PCA_computation.UMAP_computation.run_UMAP == "yes"
        scp[["proteins_batchC"]] <- scater::runUMAP(scp[["proteins_batchC"]],
                                      ncomponents = ${dimensionality_reduction.PCA_computation.UMAP_computation.ncomponents_UMAP},
                                      ntop = Inf,
                                      scale = TRUE,
                                      exprs_values = 1,
                                      n_neighbors = 3,
                                      dimred = "PCA",
                                      name = "UMAP")
  
        umap <- scater::plotReducedDim(scp[["proteins_batchC"]],
                 dimred = "UMAP",
                 colour_by = "SampleType",
                 point_alpha = 1)
        ggplot2::ggsave(filename = "UMAP.png", umap)
        #end if

        #end if

        assay_df <- as.data.frame(assay(scp, "proteins_batchC"))
        row_metadata <- as.data.frame(rowData(scp[["proteins_batchC"]]))

        export_data <- cbind(row_metadata, as.data.frame(assay_df))
        write.csv(export_data, file = '$Processed_data', sep = "\t")
        #if $data_export.export_tables
        export_all_assays(scp)
        #end if

        
        ]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="scp_param"/>
    </inputs>
    <outputs>
        <data name="Processed_data" format="txt" label="Batch-corrected protein levels"/>
        <collection name="intermediate_outputs" type="list" label="Intermediate outputs">
            <discover_datasets pattern="__name_and_ext__" directory="outputs" />
            <filter>data_export['export_tables']</filter>
        </collection>
        <data name="PCA" format="png" label="PCA plot" from_work_dir="PCA.png">
            <filter>dimensionality_reduction['PCA_computation']['run_PCA'] == 'yes'</filter>
        </data>
        <data name="UMAP" format="png" label="UMAP plot" from_work_dir="UMAP.png">
            <filter>dimensionality_reduction['PCA_computation']['run_PCA'] == 'yes' and dimensionality_reduction['PCA_computation']['UMAP_computation']['run_UMAP'] == 'yes'</filter>
        </data>
    </outputs>
    <tests>
    </tests>
    <help><![CDATA[
        @SCP_HELP@
        @GENERAL_HELP@
    ]]></help>
    <expand macro="citations" />
</tool>